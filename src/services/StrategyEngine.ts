export interface StrategyOpportunity { id: string; type: 'arbitrage' | 'momentum' | 'dca' | 'yield'; pair: string; targetProfit: number; riskScore: number; riskLevel: 'LOW' | 'MEDIUM' | 'HIGH'; timeToExecute: number; profitUsd: number; confidence: number; recommendedCapital: number; strategyName: string; outputMint?: string; executionPlan?: string[]; }
export interface StrategyResult { opportunityId: string; status: 'pending' | 'executing' | 'completed' | 'failed'; profitRealized?: number; timestamp: number; }
class StrategyEngineImpl { private activeStrategies: Map<string, StrategyOpportunity> = new Map(); private executionHistory: StrategyResult[] = []; private isRunning = false; async startAllStrategies(callback?: (opps: StrategyOpportunity[]) => void): Promise<void> { this.isRunning = true; const opportunities: StrategyOpportunity[] = [{ id: 'strat-001', type: 'arbitrage', pair: 'SOL/USDC', targetProfit: 100, riskScore: 0.3, riskLevel: 'LOW', timeToExecute: 5000, profitUsd: 100, confidence: 0.85, recommendedCapital: 5, strategyName: 'SOL-USDC Arb' }]; this.activeStrategies = new Map(opportunities.map(o => [o.id, o])); if (callback) callback(opportunities); } async stopAllStrategies(): Promise<void> { this.isRunning = false; this.activeStrategies.clear(); } getActiveStrategies(): StrategyOpportunity[] { return Array.from(this.activeStrategies.values()); } getExecutionHistory(): StrategyResult[] { return this.executionHistory; } recordExecution(result: StrategyResult): void { this.executionHistory.push({ ...result, timestamp: Date.now() }); } }
export const strategyEngine = new StrategyEngineImpl();
